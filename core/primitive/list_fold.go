package primitive; import ("fmt"; "reflect"); func ListFold(list interface{}, init interface{}, fnToken string) (interface{}, error) { v := reflect.ValueOf(list); if v.Kind() != reflect.Slice && v.Kind() != reflect.Array { return nil, fmt.Errorf("input is not a list: %v", v.Kind()) }; fn, err := getFunction(fnToken); if err != nil { return nil, fmt.Errorf("invalid function token %q: %w", fnToken, err) }; acc := reflect.ValueOf(init); for i := 0; i < v.Len(); i++ { args := []reflect.Value{acc, v.Index(i)}; results := fn.Call(args); if len(results) > 1 && !results[1].IsNil() { return nil, results[1].Interface().(error) }; acc = results[0] }; return acc.Interface(), nil }
