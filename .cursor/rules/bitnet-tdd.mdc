---
description: 
globs: 
alwaysApply: false
---
# BitNet TDD and Unit Testing Standards

## TDD Workflow

1. Red-Green-Refactor Cycle:
   - Write failing test first
   - Implement minimum code to pass
   - Refactor while keeping tests green
   - Repeat for each feature

2. Test-First Development:
   - Define interface/contract first
   - Write tests before implementation
   - Use tests to drive design
   - Verify behavior through tests

3. Implementation Steps:
   - Write test cases
   - Run tests (should fail)
   - Implement feature
   - Run tests (should pass)
   - Refactor if needed

## Test Organization

1. File Structure:
   ```
   pkg/bitnet/
   ├── component/
   │   ├── component.go
   │   └── component_test.go
   └── tests/
       └── integration/
           └── component_ops_test.go
   ```

2. Test Categories:
   - Unit tests
   - Interface tests
   - Integration tests
   - Performance tests

3. Test Naming:
   - Clear and descriptive
   - Follow Go conventions
   - Indicate test type
   - Show test purpose

## Test Implementation

1. Table-Driven Tests:
   ```go
   // Example from [pkg/bitnet/tensor/tensor_test.go](mdc:pkg/bitnet/tensor/tensor_test.go)
   func TestNewTensor(t *testing.T) {
       tests := []struct {
           name     string
           shape    []int
           wantSize int
           wantErr  bool
       }{
           // Test cases
       }
       // Test implementation
   }
   ```

2. Test Structure:
   - Setup test data
   - Define test cases
   - Run subtests
   - Verify results

3. Error Handling:
   - Test error cases
   - Verify error messages
   - Check error types
   - Handle panics

## Best Practices

1. Test Coverage:
   - Aim for high coverage
   - Test edge cases
   - Verify error paths
   - Check performance

2. Test Quality:
   - Clear test names
   - Descriptive comments
   - Proper assertions
   - Clean test data

3. Test Maintenance:
   - Keep tests simple
   - Avoid test duplication
   - Update with changes
   - Document test cases

## Test Categories

1. Unit Tests:
   - Test individual components
   - Verify basic functionality
   - Check error handling
   - Validate edge cases

2. Interface Tests:
   - Verify interface compliance
   - Test all methods
   - Check behavior
   - Validate contracts

3. Integration Tests:
   - Test component interaction
   - Verify system behavior
   - Check resource usage
   - Validate workflows

4. Performance Tests:
   - Measure execution time
   - Check memory usage
   - Verify scalability
   - Compare implementations

## Test Documentation

1. Test Comments:
   - Purpose of test
   - Test setup
   - Expected results
   - Edge cases

2. Test Organization:
   - Group related tests
   - Clear test names
   - Logical structure
   - Easy to maintain

3. Test Data:
   - Representative data
   - Edge cases
   - Error conditions
   - Performance scenarios

## Implementation Guidelines

1. Test-First Approach:
   - Write tests before code
   - Use tests to drive design
   - Verify behavior
   - Maintain coverage

2. Code Quality:
   - Keep code testable
   - Use dependency injection
   - Follow SOLID principles
   - Document interfaces

3. Refactoring:
   - Keep tests green
   - Improve code quality
   - Maintain coverage
   - Update documentation

## Common Patterns

1. Setup and Teardown:
   ```go
   func TestMain(m *testing.M) {
       // Setup
       code := m.Run()
       // Teardown
       os.Exit(code)
   }
   ```

2. Helper Functions:
   ```go
   // Example from [pkg/bitnet/tensor/tensor_test.go](mdc:pkg/bitnet/tensor/tensor_test.go)
   func floatEquals(a, b float32) bool {
       epsilon := float32(1e-6)
       return math.Abs(float64(a-b)) < float64(epsilon)
   }
   ```

3. Test Utilities:
   - Mock objects
   - Test fixtures
   - Helper functions
   - Common assertions

## Quality Assurance

1. Code Review:
   - Verify test coverage
   - Check test quality
   - Review test cases
   - Validate assertions

2. Continuous Integration:
   - Run tests automatically
   - Check coverage
   - Verify performance
   - Monitor quality

3. Maintenance:
   - Update tests regularly
   - Fix failing tests
   - Improve coverage
   - Document changes
